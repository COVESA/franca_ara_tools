package org.genivi.faracon.franca2ara.types

import com.google.inject.Inject
import org.franca.core.franca.FArgument
import org.franca.core.franca.FArrayType
import org.franca.core.franca.FAttribute
import org.franca.core.franca.FField
import org.franca.core.franca.FModelElement
import org.franca.core.franca.FStructType
import org.franca.core.franca.FTypedElement
import org.franca.core.franca.FType
import org.genivi.faracon.franca2ara.SomeipFrancaDeploymentData
import org.genivi.commonapi.someip.Deployment.InterfacePropertyAccessor
import org.genivi.commonapi.someip.Deployment.IDataPropertyAccessor

import static extension org.franca.core.FrancaModelExtensions.*

// This helper class extracts required deployment data from the Franca deployment input models and provides it in a convenient form.
class DeploymentDataHelper {
	
	@Inject
	var SomeipFrancaDeploymentData someipFrancaDeploymentData

	// Derives from the deployment data if a given array data type or the type of a given typed model element is a fixed size array.
	def isFixedSizedArray(FModelElement elem) {
		val arrayLengthWidth = elem.getArrayLengthWidth
		arrayLengthWidth!==null && arrayLengthWidth==0
	}

	// Extracts the size of fixed sized array type from the deployment data for a given array data type or the type of a given typed model element.
	def getArraySize(FModelElement elem) {
		val arrayMaxLength = elem.getArrayMaxLength
		arrayMaxLength!==null ? arrayMaxLength : 0
	}
	

	def Integer getArrayLengthWidth(FModelElement elem) {
		getDeploymentData(elem,
			[pa, e | pa.getSomeIpArrayLengthWidth(e)],
			[pa, e | pa.getSomeIpStructArrayLengthWidth(e)],
			[pa, e | pa.getSomeIpUnionArrayLengthWidth(e)],
			[pa, e | pa.getSomeIpArgArrayLengthWidth(e)],
			[pa, e | pa.getSomeIpAttrArrayLengthWidth(e)],
			[getArrayLengthWidth]
		)
	}

	def Integer getArrayMaxLength(FModelElement elem) {
		getDeploymentData(elem,
			[pa, e | pa.getSomeIpArrayMaxLength(e)],
			[pa, e | pa.getSomeIpStructArrayMaxLength(e)],
			[pa, e | pa.getSomeIpUnionArrayMaxLength(e)],
			[pa, e | pa.getSomeIpArgArrayMaxLength(e)],
			[pa, e | pa.getSomeIpAttrArrayMaxLength(e)],
			[getArrayMaxLength]
		)
	}

	
	/**
	 * <p>Retrieve SOME/IP deployment data for some Franca model element.</p>
	 * 
	 * <p>The logic being followed here is based on the pattern of the deployment
	 * properties of CommonAPI++ SOME/IP deployment. The caller has to provide a
	 * set of related deployment property accessor functions, and this method
	 * will use these in a well-defined order to get the property value which
	 * is actually valid.</p>
	 * 
	 * <p>We have to use this pattern with a lot of closures because of the
	 * specific API of PropertyAccessors generated by Franca's deployment
	 * specification generator.</p> 
	 */
	def private <T> T getDeploymentData(
		FModelElement elem,
		(IDataPropertyAccessor, FArrayType) => T f1,
		(IDataPropertyAccessor, FField) => T f2,
		(IDataPropertyAccessor, FField) => T f3,
		(InterfacePropertyAccessor, FArgument) => T f4,
		(InterfacePropertyAccessor, FAttribute) => T f5,
		(FModelElement) => T recursiveCall
	) {
		processDeployment(elem,
			[dpa |
				switch elem {
					FArrayType: f1.apply(dpa, elem)
					FField:
						elem.locallyOrViaType(recursiveCall, [
							if (elem.eContainer instanceof FStructType) {
								f2.apply(dpa, elem)
							} else {
								f3.apply(dpa, elem)
							}						
						])
					default: null
				}
			],
			[ipa |
				switch elem {
					FArgument:
						elem.locallyOrViaType(recursiveCall, [ f4.apply(ipa, elem) ])
					FAttribute:
						elem.locallyOrViaType(recursiveCall, [ f5.apply(ipa, elem) ])
					default: null
				}
			]
		)
	}
	
	/**
	 * <p>Two-step process for retrieving deployment data.</p>
	 * 
	 * <p>First try to get the data from the element itself, otherwise get the data from its type.</p>
	 */
	def private <T> T locallyOrViaType(FTypedElement elem, (FModelElement) => T recursiveCall, () => T processLocally) {
		val res = processLocally.apply()
		(res!==null) ? res : forwardToType(elem, recursiveCall)
	}

	/**
	 * <p>Helper function which calls a function on the Franca type of a typed element.</p> 
	 */
	def private <T> T forwardToType(FTypedElement te, (FType) => T func) {
		val t = te.type.derived
		if (t===null) {
			null
		} else {
			func.apply(t)
		}	
	}
	
	/**
	 * <p>Helper function for doing short-circuit execution of two functions.</p>
	 */
//	def private <T> T chain(() => T first, () => T second) {
//		val res = first.apply()
//		(res!==null) ? res : second.apply()
//	}
	
	/**
	 * <p>Get deployment data for some Franca element by checking a sequence
	 * of deployment accessors.</p>
	 * 
	 * <p>This uses the chain-of-responsibility pattern. We have a maximum of three steps:
	 * <ul>
	 * <li>check deployment data for type collection</li>
	 * <li>check deployment data for interface, but only data-related part (e.g., arrays, struct fields)</li>
	 * <li>check deployment data for interface, real interface-related part (e.g., attributes, arguments)</li>
	 * </ul>
	 * </p>  
	 */
	def private <T> T processDeployment(
		FModelElement elem,
		(IDataPropertyAccessor) => T processDataDeployment,
		(InterfacePropertyAccessor) => T processInterfaceDeployment
	) {
		val tc = elem.typeCollection
		if (tc!==null) {
			// the model element is part of a Franca type collection
			val tcpa = someipFrancaDeploymentData.lookupAccessor(tc)
			if (tcpa!==null) {
				// we have a deployment definition for this type collection
				// process the deployment for the model element
				val ret = processDataDeployment.apply(tcpa)
				if (ret!==null) {
					return ret
				}
			}
		}
		val intf = elem.interface
		if (intf!==null) {
			// the model element is part of a Franca interface definition
			val ipa = someipFrancaDeploymentData.lookupAccessor(intf)
			if (ipa!==null) {
				// we have a deployment definition for this Franca interface
				// process the deployment for the model element	(as data deployment)			
				val ret1 = processDataDeployment.apply(ipa)
				if (ret1!==null) {
					return ret1
				}
				// no data deployment applicable, check interface deployment
				val ret2 = processInterfaceDeployment.apply(ipa)
				if (ret2!==null) {
					return ret2
				}
			}
		}
		null
	}

}
